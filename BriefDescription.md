# 一句话说清楚设计模式

## 策略模式

将算法当作实体单独封装起来，方便策略的替换

例如：Android中RecyclerView的LayoutManager

## 空对象模式

创建一个不做任何处理的对象，保证流程的顺利进行

## 观察者模式

简要的说，一对多通信

例如：事件总线、ReactiveX

## 备忘录模式

保存对象状态，待以后恢复

例如：Android Activity中的onSaveInstanceState方法

## 中介者模式

对象间的直接通信改为间接通信，中间经过一个中间者

例如：MVP模式中的P属于这个中介者，分离出M和P来，M和P之间的通信规定要经过P，使界面、数据和逻辑实现了分离

## 解释器模式

例如：各种脚本、浏览器、配置文件等等

## 代理模式

由于某些情况直接操作一个对象比较麻烦，故添加这个对象的代理对象，简化访问逻辑

例如：Android中的Binder机制

## 装饰器模式

如果说继承是对对象的静态扩展，那么装饰器模式就是对对象的动态扩展，更加灵活，内聚性更好

## 组合模式

实现同一接口的对象组合成树形结构，使得客户访问这个组合和访问单个元素没有区别

例如：各种GUI框架，显示的元素统统继承于一个父亲

## 模板模式

封装固定的逻辑，开放可以自定义的接口

例如：GUI的控件，封装了复杂的事件传递逻辑还有绘图逻辑，开放了一些事件接收和绘图事件的回调，这就实现了模板的可定制

## 访问者模式

数据固定，访问方式可变，这时可以分离出一个访问者类型，实现了访问方式的可定制

例如：java TreeMap中的Comparator可以看做是访问者，这个访问者可以定义TreeMap中key的有序性，而不用了解TreeMap中的任何细节


